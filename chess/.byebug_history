exit
color
moves[4]
moves[3]
moves[2]
moves[1]
moves[0]
moves[0].pos
moves.length
same.each { |el| moves.concat(el.valid_moves) }
moves = []
same.each do |el|
color
same.length
same = rows.flatten.select { |pc| pc.color == color }
rows.flatten.select { |pc| pc.color == color }
s
n
in_check?(color)
s
c
exit
c
exit
board.check_mate?(curr_player)
c
exit
board.is_null?(pos)c
board.is_null(pos)
n
board.in_bounds?(pos)
pos
s
curr_x
n
s
display [x,y]
n
[x, y]
s
possible_moves
n
pos
board.in_bounds?(pos)
s
dy
dx
pos
s
possible_moves
s
self.color
self.class
self
s
pos
s
n
color
piece.color
piece.pos
piece.class
s
end_pos
start_pos
color
s
to
from
c
exit
king_pos
n
color
s
c
q
pc.moves
n
display pc.class
display color
display pc.color
pc
s
n
color
s
c
q
back
b
n
s
display pc.class
display color
display pc.color
s
color
pc.color
pc
s
n
s
c
q
c
n
nn
n
pc
s
pc
s
n
s
c
q
c
n
s
get_pieces.length
get_pieces
king_pos
n
color
s
c
q
in_bounds?(end_pos)
n
s
end_pos
start_pos
s
to
from
q
c
s
q
c
pos
q
quit
c
s
@rows
s
dup_board
s
fill
s
fill
s
q
s
pos
s
n
s
piece.pos
c
piece.pos
q
pos
s
piece.color
piece.class
c
piece.class
piece
c
n
c
s
other_color
s
other_color
s
color
s
n
s
self[start_pos]
self[end_pos]
s
pos
s
piece.pos
piece.color
piece.class
piece
c
s
board.in_bounds?(poss_move)
poss_move
s
curr_x
s
curr_x
s
curr_y
curr_x
s
q
get_all_moves(other_color)
king_pos
n
other_color
n
color
c
other_color
king_pos
n
c
king_pos
n
get_all_moves(other_color)
other_color
king_pos
n
get_all_moves(other_color)
other_color
king_pos
n
get_all_moves(other_color)
other_color
n
other_color
n
king_pos
n
king_pos
get_all_moves(other_color)
n
c
s
other_color
n
other_color
n
king_pos
n
q
king_pos
n
q
king_pos
n
q
possible_moves
n
c
q
@pos
